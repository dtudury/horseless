function t(t, e) {if (!t[t.i].match(e)) throw new Error(`expected ${e}. got ${t[t.i]} at i=${t.i}`);t.i++;}function e(t) {if (t[t.i].isValue) return t[t.i++];}function n(e) {if (t(e, /&/), o(e, "amp;")) return "&";if (o(e, "apos;")) return "'";if (o(e, "gt;")) return ">";if (o(e, "lt;")) return "<";if (o(e, "quot;")) return '"';throw new Error("unhandled escape sequence");}function r(t, e) {const r = [];for (; t.i < t.length;) {const i = t[t.i];if (i.isValue || i.match(e)) return r.join("");"&" === i ? r.push(n(t)) : (r.push(i), t.i++);}return r.join("");}function i(t) {r(t, /\S/);}function o(t, e) {e.length || (e = [e]);const n = [];for (let r = 0; r < e.length; r++) {const i = t[t.i + r];if (!i || !i.match || !i.match(e[r])) return !1;n.push(i);}return t.i += e.length, n.join("");}const s = new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]),u = Symbol("end");function a(s) {i(s);const a = s[s.i];if ("/" === a || ">" === a) return u;let c = e(s);if (c && c.isValue) return c.value;if (c = r(s, /[\s=/>]/), !c) throw new Error("attribute must have a name (dynamic attributes okay, dynamic names... sorry)");if (i(s), o(s, "=")) {i(s);let u = e(s);if (u) u = u.value;else {const e = o(s, /['"]/);e ? (u = function (t, e) {const r = [];let i = [];for (; t.i < t.length;) {const o = t[t.i];if (o.isValue) i.length && (r.push({ type: "part", value: i.join("") }), i = []), r.push(o.value), t.i++;else {if (o.match(e)) return i.length && r.push({ type: "part", value: i.join("") }), r;"&" === o ? i.push(n(t)) : (i.push(o), t.i++);}}}(s, e), t(s, e)) : u = r(s, /[\s=/>]/);}return { type: "attribute", name: c, value: u };}return { type: "attribute", name: c };}function c(e) {const n = e[e.i];if (n.isValue) return e.i++, n.value;if ("<" === n) {t(e, /</);const n = o(e, "/"),c = function (t) {i(t);const e = t[t.i];return e.isValue ? (t.i++, e.value) : r(t, /[\s/>]/);}(e),f = s.has(c),h = function (t) {const e = [];for (;;) {const n = a(t);if (n === u) return e;e.push(n);}}(e),p = o(e, "/") || f;t(e, />/);const y = n || p ? [] : l(e, c);return f && n ? null : { type: "node", tag: c, attributes: h, children: y, isClosing: n };}return { type: "textnode", value: r(e, /</) };}function l(t, e) {const n = [];for (; t.i < t.length;) {const r = c(t);if (null != r) if (r.isClosing) {if (null != e) return n;} else delete r.isClosing, n.push(r);}return [].concat.apply([], n);}function f(t, ...e) {const n = [t[0].split("")];for (let r = 0; r < e.length; r++) n.push({ value: e[r], isValue: !0 }), n.push(t[r + 1].split(""));const r = [].concat.apply([], n);return r.i = 0, l(r, null);}const h = new Set(),p = new Map(),y = new Set(),d = new Set(),g = [],m = [],b = Symbol("ownKeys as attribute");let w = !1;function v(t, e) {if (p.has(e)) {const n = p.get(e);if (n.has(t)) {w || (w = !0, requestAnimationFrame(() => {w = !1;for (const t of d) t();for (d.clear(); m.length;) m.shift()();}));for (const e of n.get(t)) d.add(e);n.delete(t), n.size || p.delete(e);}}}function j(t, e) {if (g.length) {p.has(e) || p.set(e, new Map());const n = p.get(e);n.has(t) || n.set(t, new Set()), n.get(t).add(g[0]);}}function x(t = {}) {if (t instanceof Object && !h.has(t)) {const e = new Proxy(Array.isArray(t) ? new Array(t.length) : {}, { has: (t, e) => (j(t, e), e in t), get: (t, e) => (j(t, e), t[e]), set: (t, e, n) => (n = x(n), t[e] === n && "length" !== e || (e in t || v(t, b), v(t, e)), t[e] = n, !0), deleteProperty: (t, e) => (e in t && (v(t, b), v(t, e)), Reflect.deleteProperty(t, e)), ownKeys: t => (j(t, b), Reflect.ownKeys(t)) });Object.assign(e, t), h.add(e), t = e;}return t;}function A(t) {y.has(t) || (y.add(t), function e() {y.has(t) && (g.unshift(e), t(), g.shift());}());}function O(t) {y.delete(t);}function E(t) {m.push(t);}function S(t, e) {let n = {};return t.forEach(t => {if ("function" == typeof t && (t = t(e)), null != t) if (t && "attribute" === t.type) {const r = t.name;if (Object.prototype.hasOwnProperty.call(n, r)) return;const i = function (t, e) {if (null == t) return null;if ("function" == typeof t && (t = t(e)), Array.isArray(t)) {const n = t.map(t => ("function" == typeof t && (t = t(e)), null == t ? "" : t && "part" === t.type ? t.value : t));return 1 === n.length ? n[0] : n.join("");}return t;}(t.value, e);n[r] = null == i ? r : i;} else if (Array.isArray(t)) n = Object.assign(S(t, e), n);else if ("object" == typeof t) Object.entries(t).forEach(([t, e]) => {Object.prototype.hasOwnProperty.call(n, t) || (n[t] = e);});else {const e = t.toString();if (Object.prototype.hasOwnProperty.call(n, e)) return;n[e] = e;}}), n;}function V(t, e) {return Object.entries(e).forEach(([e, n]) => {!function (t, e, n) {if (t[e] !== n) try {t[e] = n;} catch (t) {}if ((typeof n).match(/(?:boolean|number|string)/)) {const r = n.toString();t.getAttribute(e) !== r && t.setAttribute(e, r);}}(t, e, n);}), t;}const C = new Map();function P(t, e) {Array.isArray(t) || (t = [t]);const n = [];return t.forEach(t => {if ("function" == typeof t && (t = t()), null != t) if (Array.isArray(t)) n.push(...P(t, e));else if (null === t.tag || "" === t.tag) n.push(...P(t.children, e));else if ("function" == typeof t.tag) n.push(...P(t.tag(S(t.attributes), t.children, t)));else if (t.type) {if (!C.has(t)) {let n;if ("textnode" === t.type) n = document.createTextNode(t.value);else {let r = {},i = S(t.attributes, n);n = document.createElementNS(i.xmlns || e, t.tag, { is: t.attributes.is }), V(n, i), k(n, t.children, i.xmlns || e), A(() => {i = S(t.attributes, n), V(n, i), function (t, e, n) {const r = new Set(Object.keys(n));Object.keys(e).forEach(t => r.delete(t)), r.forEach(e => {t.removeAttribute(e), delete t[e];});}(n, i, r), r = i;});}C.set(t, n);}n.push(C.get(t));} else n.push(document.createTextNode(t.toString()));}), n;}function k(t, e, n = "http://www.w3.org/1999/xhtml") {if (!e) return P(t, n);A(function () {return function (t, e, n) {const r = P(e, n);for (r.forEach((e, n) => {const r = t.childNodes[n];r ? e !== r && t.insertBefore(e, r) : t.appendChild(e);}); t.childNodes.length > r.length;) t.removeChild(t.lastChild);return t;}(t, e, n);});}function N(t, e, n = []) {return () => t() ? e : n;}function M(t, e) {const n = new Map();return () => {const r = "function" == typeof t ? t() : t;n.forEach(t => {t.index = 0;});const i = Object.entries(r).map(([t, r]) => {n.has(r) || n.set(r, { index: 0, values: [] });const i = n.get(r);return i.values.length <= i.index && i.values.push(e(r, t)), i.values[i.index++];});return n.forEach((t, e) => {t.index ? t.values.splice(t.index) : n.delete(e);}), i;};}export { E as after, f as h, M as mapEntries, x as proxy, k as render, N as showIfElse, O as unwatchFunction, A as watchFunction };