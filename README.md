# horseless

## HTML-like markup. Auto-updating elements.
Paste in your html and work in your model. When you update your model the DOM updates itself. No compiling and nothing is virtual.

### Three main parts

#### Part 1: `h`, a template tag

`h` parses xml with interspersed arguments. It outputs a simple description of DOM objects. 

```
import { h } from 'horseless'

const astronaut = 'Dave'
const descriptions = h`I'm sorry <span>${astronaut}</span>, I'm afraid I can't do that`
console.log(JSON.stringify(descriptions, null, '  '))
```

output:
```
[
  {
    "type": "textnode",
    "value": "I'm sorry "
  },
  {
    "type": "node",
    "tag": "span",
    "attributes": {},
    "children": [
      "Dave"
    ],
    "isClosing": false,
    "isEmpty": false,
    "xmlns": "http://www.w3.org/1999/xhtml"
  },
  {
    "type": "textnode",
    "value": ", I'm afraid I can't do that"
  }
]
```
[see it working](https://horseless.info/h/)

Nothing mind blowing yet. The part that's going to be interesting later is that if you pass it a function as an argument it puts the function where it belongs in the description.

#### Part 2: `render` it onto the page

`render` takes a DOM element and an array of descriptions (generated by `h`). It creates actual DOM elements and sets them as the children of the passed in element. 

```
import { h, render } from 'horseless'

function fourFiveSix () {
  return h`<div>4</div><div>5</div><div>6</div>`
}

render(document.querySelector('.count'), h`
  <div>0</div>
  <>
    <div>1</div>
    <div>2</div>
    <div>3</div>
  </>
  ${fourFiveSix}
  ${[7, 8, 9].map(v => h`<div>${v}</div>`)}
`)
```
[see it working](https://horseless.info/render/)

Functions used as template arguments are evaluated at render time. Arrays are flattened.

#### Part 3: `remodel` your model

`remodel` creates a proxy of whatever object you give it. The proxy keeps track of which values were read during renders. If any of those values are changed later the corresponding child node or attribute are updated.

```
import { h, render, remodel } from 'horseless'

const model = remodel({seconds: 0})
setInterval(() => model.seconds++, 1000)

render(document.body, h`
  <span>hello world! seconds running: ${() => model.seconds.toString()}</span>
`)
```
[see it working](https://horseless.info/remodel/)


#### complete example
There's a todomvc example in the docs folder. You can see it running at https://horseless.info/todomvc/

### things to know
attributes starting with 'on' won't get called before being set
```
h`<span class=${functionThatReturnsClasses}> click me </span>` // this works as you'd expect it to
h`<span onclick=${e => console.log('click', e)}> click me </span>` // this also works as you'd expect it to (but differently)
```

don't put quotes around embedded expression attributes
```
h`<span class="${functionThatReturnsClasses}"> click me </span>` // this won't work
```

If you come across more things that may be confusing, please file an issue

## but it's not really html, is it?
Well, no... it only handles elements and doesn't check that your tags are valid or anything
```
let elements = h`
<!DOCTYPE html> // can't do this
<input autofocus> // or this
<!-- comment --> // or this
`
```
nope nope nope

## Ugh! not another bloated framework!
The first iteration of this project was just the template literal xhtml parsing. The model stuff was just for the demo... but it was so cool (imho) it got moved into the project proper. That said, the goal of this project is to enable transformations from models to views. Having the view update as the model updates seemed to be in line with that goal. 

There's around 400 code-golf-free lines with no external dependencies. you can read through all the code and understand every subtle nuance in an hour

The gzipped minified version is 2k

## todo
* better handle xml != html?
  * handle boolean attributes (without values `<input autofocus/>`)
  * handle void elements (without closing tags `<br>`)
* less adding and removing when splicing child nodes lists
* that templating thing that lit does might be cool (or some other way to not create new elements when updating big blocks of html)...
