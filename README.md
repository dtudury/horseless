# horseless

## HTML-like markup. Auto-updating elements.
Paste your html into a template and use functions of your model for the arguments. When you update your model the DOM updates itself. No compiling and nothing is virtual.

### Three main parts: `h`, `render`, `remodel`

#### Part 1: `h`, a template tag

`h` turns XML with interspersed arguments into a simple object based description of DOM objects. 

It's an XML parser with the additional feature that it operates on string literals so that arguments can be copied into the DOM description (where appropriate). This allows `render` to expand any functions copied into the description itself and allows any web-components to receive real objects as properties.

[see it working](https://horseless.info/h/)

#### Part 2: `render` it onto the page

`render` takes a DOM element and an array of descriptions (generated by `h`). The descriptions are turned into actual DOM elements and set as children of the passed in element. 

```
import { h, render } from 'horseless'

function fourFiveSix () {
  return h`<div>4</div><div>5</div><div>6</div>`
}

render(document.querySelector('.count'), h`
  <div>0</div>
  <>
    <div>1</div>
    <div>2</div>
    <div>3</div>
  </>
  ${fourFiveSix}
  ${[7, 8, 9].map(v => h`<div>${v}</div>`)}
`)
```
[see it working](https://horseless.info/render/)

Functions used as arguments (`fourFiveSix`) are evaluated at render time. Arrays are expanded recursively. So if your argument is a function that returns an array of functions that return arrays themselves you still get a flat DOM.

#### Part 3: `remodel` your model

`remodel` creates a proxy of whatever object you give it. The proxy keeps track of which values were read during renders. If any of those values are changed later the corresponding child node or attribute are updated.

```
import { h, render, remodel } from 'horseless'

const model = remodel({seconds: 0})
setInterval(() => model.seconds++, 1000)

render(document.body, h`
  <span>hello world! seconds running: ${() => model.seconds.toString()}</span>
`)
```
[see it working](https://horseless.info/remodel/)


#### more complete example
There's a todomvc example in the docs folder. You can see it running at https://horseless.info/todomvc/

### things to know
attributes starting with 'on' won't get called before being set
```
h`<span class=${functionThatReturnsClasses}> click me </span>` // this works as you'd expect it to
h`<span onclick=${e => console.log('click', e)}> click me </span>` // this also works as you'd expect it to (but differently)
```

don't put quotes around embedded expression attributes
```
h`<span class="${functionThatReturnsClasses}"> click me </span>` // this won't work
```

If you come across more things that may be confusing, please file an issue

## but it's not really html, is it?
Well, no... it only handles elements and doesn't check that your tags are valid or anything
```
let elements = h`
<!DOCTYPE html> // can't do this
<input autofocus> // or this
<!-- comment --> // or this
`
```
nope nope nope

## Ugh! not another bloated framework!
The first iteration of this project was just the template literal xhtml parsing. The model stuff was just for the demo... but it was so cool (imho) it got moved into the project proper. That said, the goal of this project is to enable transformations from models to views. Having the view update as the model updates seemed to be in line with that goal. 

There's around 400 code-golf-free lines with no external dependencies. you can read through all the code and understand every subtle nuance in an hour

The gzipped minified version is 2k

## todo
* documentation...
* better handle xml != html?
  * handle boolean attributes (without values `<input autofocus/>`)
  * handle void elements (without closing tags `<br>`)
* less adding and removing when splicing child nodes lists
