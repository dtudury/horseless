# horseless

## HTML-like markup. Auto-updating elements.
Paste your html into a template and use functions of your model for the arguments. When you update your model the DOM updates itself. No compiling and nothing is virtual.

### Three main parts: `h`, `render`, `remodel`

#### Part 1: `h`, a template tag

`h` parses xml with interspersed arguments. It outputs a simple description of DOM objects. 

```
import { h } from 'horseless'

const astronaut = 'Dave'
const descriptions = h`I'm sorry <span>${astronaut}</span>, I'm afraid I can't do that`
console.log(JSON.stringify(descriptions, null, '  '))
```

output:
```
[
  {
    "type": "textnode",
    "value": "I'm sorry "
  },
  {
    "type": "node",
    "tag": "span",
    "attributes": {},
    "children": [
      "Dave"
    ],
    "isClosing": false,
    "isEmpty": false,
    "xmlns": "http://www.w3.org/1999/xhtml"
  },
  {
    "type": "textnode",
    "value": ", I'm afraid I can't do that"
  }
]
```
[see it working](https://horseless.info/h/)

Is your mind blown yet? No?! Well the part that's going to be interesting later is when you pass a function as an argument it ends up intact in the description.

#### Part 2: `render` it onto the page

`render` takes a DOM element and an array of descriptions (generated by `h`). The descriptions are turned into actual DOM elements and set as children of the passed in element. 

```
import { h, render } from 'horseless'

function fourFiveSix () {
  return h`<div>4</div><div>5</div><div>6</div>`
}

render(document.querySelector('.count'), h`
  <div>0</div>
  <>
    <div>1</div>
    <div>2</div>
    <div>3</div>
  </>
  ${fourFiveSix}
  ${[7, 8, 9].map(v => h`<div>${v}</div>`)}
`)
```
[see it working](https://horseless.info/render/)

Functions used as template arguments are evaluated at render time. Arrays are expanded recursively. So if your argument is a function that returns an array of functions that return arrays themselves you still get a flat DOM.

#### Part 3: `remodel` your model

`remodel` creates a proxy of whatever object you give it. The proxy keeps track of which values were read during renders. If any of those values are changed later the corresponding child node or attribute are updated.

```
import { h, render, remodel } from 'horseless'

const model = remodel({seconds: 0})
setInterval(() => model.seconds++, 1000)

render(document.body, h`
  <span>hello world! seconds running: ${() => model.seconds.toString()}</span>
`)
```
[see it working](https://horseless.info/remodel/)


#### more complete example
There's a todomvc example in the docs folder. You can see it running at https://horseless.info/todomvc/

### things to know
attributes starting with 'on' won't get called before being set
```
h`<span class=${functionThatReturnsClasses}> click me </span>` // this works as you'd expect it to
h`<span onclick=${e => console.log('click', e)}> click me </span>` // this also works as you'd expect it to (but differently)
```

don't put quotes around embedded expression attributes
```
h`<span class="${functionThatReturnsClasses}"> click me </span>` // this won't work
```

If you come across more things that may be confusing, please file an issue

## but it's not really html, is it?
Well, no... it only handles elements and doesn't check that your tags are valid or anything
```
let elements = h`
<!DOCTYPE html> // can't do this
<input autofocus> // or this
<!-- comment --> // or this
`
```
nope nope nope

## Ugh! not another bloated framework!
The first iteration of this project was just the template literal xhtml parsing. The model stuff was just for the demo... but it was so cool (imho) it got moved into the project proper. That said, the goal of this project is to enable transformations from models to views. Having the view update as the model updates seemed to be in line with that goal. 

There's around 400 code-golf-free lines with no external dependencies. you can read through all the code and understand every subtle nuance in an hour

The gzipped minified version is 2k

## todo
* documentation...
* better handle xml != html?
  * handle boolean attributes (without values `<input autofocus/>`)
  * handle void elements (without closing tags `<br>`)
* less adding and removing when splicing child nodes lists
